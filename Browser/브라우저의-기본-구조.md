# Browser?
```
ex. FireFox, Chrome, IE, Edge, Opera, Safari 등
```
> 웹 서버를 이동(navigate)하며 쌍방향으로 통신하고 html 문서나 파일을 출력하는 GUI(*Graphical User Interface*) 기반의 응용 소프트웨어.
> 
> 주요 기능 : 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것. 자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해진다.

## 브라우저의 기본 구조
__1. 사용자 인터페이스 (User Interface)__
- 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다.

__2. 브라우저 엔진__
- 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어

__3. 렌더링 엔진__
- 요청한 콘텐츠를 표시, 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시

__4. 통신__
- HTTP 요청과 같은 네트워크 호출에 사용됨. 이것은 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행

__5. 자바스크립트 해석기__
- Javascript 코드를 해석하고 실행한다. Javascript Interpreter. 자바스크립트 엔진이라고도 함.

__6. UI 백엔드__
- 기본적인 위젯을 그리는 인터페이스(select, input 등). 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용.

__7. 자료 저장소__
- Cookie, Local Storage 등과 같이 브라우저 메모리를 활용하여 데이터를 저장
- 자료를 저장하는 계층, 모든 종류의 자원을 하드디스크에 저장, HTML5 명세에는 브라우저가 지원하는 ‘웹 데이터 베이스’가 정의되어있음.

## 렌더링 엔진
요청 받은 내용을 브라우저 화면에 표시하는 역할

__브라우저별 렌더링 엔진__
- 파이어폭스 : Mozilla에서 직접 만든 `게코(Gecko)` 엔진 사용
- 사파리, 크롬 : `웹킷(Webkit)` 엔진 사용

__동작 과정__
- DOM(Document Object Model) Tree 생성
   - HTML Document를 Parser로 파싱 후 DOM Tree를 생성한다.
- Style Rule 생성   
   - CSS Parser는 CSS를 분석하여 Style Rule을 생성한다.
- DOM Tree와 Style Rule로 Render Tree 생성
   - DOM 트리의 각 Element에 Style Rule을 적용하여 렌더 트리를 생성합니다. 
   - <head>, <title>, <script>는 표시되지 않는 노드이므로 렌더 트리에 미포함 
   - display: none 또한 렌더 트리에 미포함
   - visibility: hidden이 적용된 노드는 눈에 안보일 뿐 렌더트리에 포함
- Render Tree를 배치    
   - 생성된 렌더 트리에서 위치나 크기 정보를 계산하여 생성한다.
   - 상대 값은 본 과정에서 절대 값으로 변환되어 표현됨
- Render Tree 그리기
   - 렌더트리를 순회하면서 화면에 노드를 노출한다.
## 파싱과 DOM 트리 구축
__Parsing__
  
- 문서 파싱 : 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것을 의미
- 파싱 결과 : 문서 구조를 나타내는 노드 트리. 파싱 트리(Parsing Tree) 또는 문법 트리(Syntax Tree)

**문법**

- 문서에 작성된 언어 또는 형식의 규칙을 따른다. 문맥 자유 문법. 기계적 파싱이 불가능
- 구문은 보통 BNF라고 부르는 형식에 따라 정의.

### 파서-어휘 분석기 조합

**어휘 분석**

- 자료를 토큰으로 분해하는 과정. 토큰은 유효하게 구성된 단위의 집합체, 용어집. 사전에 등장하는 모든 단어에 해당.

**구문 분석**

- 언어의 구문 규칙을 적용하는 과정

**파서**

- 자료를 유효한 토큰으로 분해하는 어휘 분석기가 있고 언어 구문 규칙에 다라 문서 주고를 분석함으로써 파싱 트리를 생성하는 파서가 있다. 어휘 분석기는 공백과 줄 바꿈 같은 의미 없는 문자를 제거한다.
- 파싱 과정은 반복된다. 파서는 보통 어휘 분석기로부터 새 토큰을 받아서 구문 규칙과 일치하는지 본다. 규칙에 맞으면 토큰에 해당하는 노드각 파싱 트리에 추가되고 파서는 또 다른 토큰을 요청한다.
- 규칙에 맞지 않으면 파서는 토큰을 내부적으로 저장하고 일치하는 규칙이 발생할 때까지 요청한다. 맞는 규칙이 없는 경우 예외로 처리하는데, 이건 문서가 유효하지 않고 구문 오류를 포함하고 있다는 의미.
- 하향식 파서와 상향식 파서가 있다. 하향식 파서는 구문의 상위 구조로부터 일치하는 부분을 찾기 시작하는데 반해 상향식 파서는 낮은 수준에서 점차 높은 수준으로 찾는다.
- 상향식 파서는 입력값이 규칙에 맞을 때가지 찾아서 맞는 입력 값을 규칙으로 바꾸는데 이 과정은 입력값의 끝까지 진행됨.

**변환**

- 파서 트리는 최종 결과물이 아님. 파싱은 보통 문서를 다른 양식으로 변환하는데 컴파일이 하나의 예가 된다. 소스 코드를 기계 코드로 만드는 컴파일러는 파싱 트리 생성 후 이를 기계 코드 문서로 변환힌다.

**파서 자동 생성**

- 파서를 생성해줄 수 있는 도구. 파서 생성기. 언어에 어휘나 구문 규칙 같은 문법을 부여하면 동작하는 파서를 만들어줌.
- 웹킷은 어휘 생성을 위한 플렉스(Flex)와 파서 생성을 위한 Bison(바이슨)을 사용

### HTML 파서

- HTML 파서는 HTML 마크업을 파싱 트리로 변환한다.
- HTML의 어휘와 문법은 W3C에 의해 명세로 정의. 문맥 자유 문법이 아님.
- HTML에는 모든 전통적인 파서를 적용할 수 없다. 파싱은 CSS와 자바스크립트를 파싱하는 데에 사용된다. 

정리하자면 HTML은 파싱하기 어렵고 전통적인 구문 분석이 불가능하기 때문에 문맥 자유 문법이 아니라는 것

1. 언어의 너그러운 속성.
2. 잘 알려져 있는 HTML 오류에 대한 브라우저의 관용.
3. 변경에 의한 재파싱. 일반적으로 소스는 파싱하는 동안 변하지 않지만 HTML에서 document.write을 포함하고 있는 스크립트 태그는 토큰을 추가할 수 있기 때문에 실제로는 입력 과정에서 파싱이 수정된다.

### DOM Document Object Model

- 파싱 트리는 DOM 요소와 속성 노드의 트리로서 출력 트리가 된다. DOM은 문서 객체 모델의 준말. 
  - 이것은 HTML 문서의 객체 표현이고 외부를 향하는 자바스크립트와 같은 HTML요소의 연결 지점이다.
- 트리의 최상위 객체는 문서임.
- DOM은 마크업과 1:1의 관계를 맺는다.
- 트리가 DOM 노드를 포함한다고 말하는 건 DOM 접점의 하나를 실행하는 요소를 구성한다는 의미.  
  
```
브라우저 렌더링 엔진, HTML 파싱, CSS 파싱, DOM 노드 트리, 렌더 트리, CSS 우선순위, repaint, reflow, trigger
간결하게 정리해서 업데이트 에정
```
  
## 참고 
[브라우저는 어떻게 동작하는가?](https://d2.naver.com/helloworld/59361)
